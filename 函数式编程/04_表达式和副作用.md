# 表达式和副作用

从这篇文章开始, 我将介绍函数式的程序员们最喜欢挂在嘴边的两个概念 - "表达式" 和 "副作用"

每个推销/传教函数式的人都会兴奋地向你大喊 "程序由表达式构成的" 是多么的简洁, "要控制副作用" 是多么的有必要

而我会用一些小例子向你说明这些问题, 带你走进函数式的美丽世界

> 一些提示: 在这篇文章中, 我将继续使用 Scala 3 语言, 这是一个语法类似 Python 的 JVM 语言, 所以不需要你学习过这门语言也能看懂它; 但 Scala 中的一些特性确实会让没有使用过的程序员感到疑惑, 特别是 "隐式参数" 和 "隐式转换", 你可以大致地将 "隐式参数" 当作 "编译时依赖注入", 将 "隐式转换" 当作 "编译时自动类型转换"; 碰到这些特性, 无需了解背后是什么原理, 了解它起到了什么作用即可

## 从结构化的程序开始

在典型的结构化程序设计语言中 (比如 C 语言), 程序是在流程控制语句的作用下从上到下, 一条一条地执行, 期间也会发生函数的调用和返回, 但总体上, 这个 "从上到下" 和 "一条一条" 的特点非常明显, 这和汇编语言/机器码太像了, 是符合计算机工作原理的

就写一段找最大的程序看看吧:

```scala
@main
def run(args: String*): Unit =
  var array = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
  var max = array(0)

  var index = 1
  while index < 10 do
    if max < array(index) then
      max = array(index)

    index += 1

  println(max)
```

C 语言的代码基本上就和上面的差不多, 我们要考虑数组下标从几开始到几结束的问题, 还要考虑什么时候更新 `max` 的值, 这实在太 "贴近机器" 了

## 试试函数式

那我们就试试函数式的写法吧

```scala
@main
def run(args: String*): Unit =
  val array = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
  val max = array.max

  println(max)
```

什么? 数组上有 `max` 方法吗?

实际上, 作为一门 JVM 上的语言, 原生数组上确实没有 `max` 能让我们调用, 但在隐式转换和隐式参数的作用下, 我们确实得到了 `max` 方法, 将上面那行代码中的隐式特性展开后大致是这样的:

```scala
val max = wrapIntArray(array).max(Ordering[Int])
//        ^^^^^^^^^^^^^^^^^^^
//           ArraySeq.ofInt
```

## 从 var 到 val

看了上面的例子, 你现在心里肯定有一个疑问, 那就是这两段代码实现的功能是一样的啊, 如果函数式只是写起来短的话那实际上没什么优势, 况且或许 `ArraySeq.ofInt` 的 `max` 其实跟我们的实现差不多呢

那我告诉你, 写函数式的代码时, 程序员的心智负担是更小的, 下面我就展开说说

先不说 `max` 是如何实现, 我们从使用变量 `var` 转换到了使用常量 `val`, 常量给我们的意义就是我们无需再操心它引用的值有没有在变了; 既然值不变, 就不会再有数组下标指到了谁的问题, 也不会有当前的值是否比所记录值大的问题, 我们可以进行大胆的值 "代换", 就像数学公式中的那些字母一样, 常量只不过是一个值的名字, 它等于多少就代换成多少

## 表达式

有了常量, 我们就可以构建表达式, 表达式并不像语句, "从上到下" 和 "一条一条" 地执行, 而是由小的表达式组合成大的表达式, 最终整个程序就是一个超级巨大的表达式, 运行程序就是对这个大表达式求值

```scala
val x = 1
// 常量是值的名字
val y = x + 2
val y = 1 + 2
val y = 3
// 表达式中的常量可以代换求值
def doubled(i: Int): Int =
  i * 2
// 函数是一种接受参数的表达式
val z = doubled(y)
val z = doubled(x + 2)
val z = doubled(1 + 2)
val z = doubled(3)
val z = 3 * 2
val z = 6
// 函数仍满足代换求值的规律
// 程序就这样由表达式组合起来
```

## 函数式的 `max`

现在, 请仔细思考一个问题, 程序如果只有常量, 表达式, 函数这三种元素, 怎样才能写出一个 `max` 函数呢?

```scala
def max(array: Array[Int]): Int =
  ???
```

请发动脑筋, 回想回想迄今为止你学到的所有编程技巧, 或许你心中已经想到了那个办法, 只是还有点迟疑它是否可行:

"递归"

```scala
def maxIn(array: Array[Int]): Int =
  val length = array.length

  @tailrec
  def loop(max: Int, index: Int): Int =
    if index < length then
      val curr = array(index)
      val maximum = if max < curr then curr else max
      loop(maximum, index + 1)
    else max

  loop(array(0), 1)
```

实际上这样的递归是很直观的, 将我们在结构化的程序中写的循环变量全部转成函数的参数, 在函数中判断什么时候停止递归进行求值

那我们来评价一下, 我们说结构化的程序之所以难懂, 是因为程序中有让我们操心的各种和程序流有关的变量, 这种变量在函数式的版本中消除掉了, 所以写函数式的代码时程序员的心智负担更少

## 认识程序中的副作用

**程序依赖 "副作用" 运行**, 函数式程序员们口中所谓的 "副作用" 主要包括:

- 声明并读写全局的变量
- 标准输入/输出
- 读写文件/缓冲区/数据库/消息队列
- 通过网络发送和接收数据

如果我们只凭可爱的常量/表达式/函数的代换, 显然无法做到这些, 但如果不做这些, 我们的程序就只是做了计算, 不考虑计算过程中的耗电和发热的话, 它就没有对外部世界产生什么影响, 换言之它就没有为我们做什么工作

至少, 我是说至少, 程序应当把计算的结果给我们打印出来吧

```scala
val x: Unit = println(1)
val y: Unit = println(2)

x == y  // true
x == () // true
```

`Unit` 类型类似 Java 中的 `void`, 它只有一个值 `()`, 很多只起副作用的函数都会返回一个 `Unit` 类型的值用来占位, 可是显然 `()` 与 `println(1)` 之间不能代换, `println(1)` 与 `println(2)` 也不一样, 这破坏了表达式代换求值的规则, 所以那些有副作用代码的不能用来直接构建进表达式里

## 如何控制副作用

就像变量破坏了代换一样, 副作用也破环了代换, 我们可以通过一些手段不使用变量, 但我们的程序依赖副作用运行, 所以我们要想办法控制它

函数式的程序员们想到了一个很直观的办法: 将有副作用的代码包装起来, 包装进一个函数, 我们就当函数是一个值, 这样作为一条数据, 它就能加入到表达式中, 然后构建大的表达式, 只有在程序真正运行的时候, 需要对这个包含副作用的部分求值的时候再运行其中的副作用

```scala
val x = () => println(1)
val y = () => println(2)

// 代换时:
x == y          // false
x == (() => ()) // false

// () => ??? 是一个 lambda 表达式
// 或者也叫箭头函数
// 它就是一个不接收参数的函数
// 我们把包含副作用的代码包装进了函数里
// 只有调用函数的时候才会求值

// 求值时:
x() == y() // true
x() == ()  // true
```

这样的作法其实不是什么新鲜事, 我们常在写异步的代码时设计一个 "回调参数", 你仔细想想, 所谓的 "回调" 的思想和 "包装副作用" 其实是一回事, 都是想要把一部分代码包起来, 需要的时候再执行, "回调" 只是 "包装副作用" 的一例

## 一些我自己的想法

现在你发现了, 消除变量靠函数, 控制副作用也靠函数, 再将数据的操作分离成函数, 函数式的程序员们是一群追求简单, 相信用函数解决所有问题的人
